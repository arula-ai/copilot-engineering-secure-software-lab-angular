---
description: Generate secure fix for XSS vulnerabilities (Lab 3)
---

# XSS Vulnerability Fix Generator

Generate a secure implementation to fix XSS vulnerabilities in Angular components.

## Fix Strategies

### Strategy 1: HTML Sanitization with Allowlist

For cases where HTML rendering is required:

```typescript
const ALLOWED_TAGS = ['b', 'i', 'u', 'strong', 'em', 'p', 'br', 'ul', 'ol', 'li', 'a', 'span'];
const ALLOWED_ATTRS = ['href', 'class'];
const ALLOWED_PROTOCOLS = ['http:', 'https:', 'mailto:'];

function sanitizeHtml(html: string): string {
  const parser = new DOMParser();
  const doc = parser.parseFromString(html, 'text/html');

  function clean(node: Node): void {
    if (node.nodeType === Node.ELEMENT_NODE) {
      const el = node as Element;
      const tag = el.tagName.toLowerCase();

      // Remove disallowed tags
      if (!ALLOWED_TAGS.includes(tag)) {
        el.remove();
        return;
      }

      // Clean attributes
      Array.from(el.attributes).forEach(attr => {
        // Remove non-allowed attributes
        if (!ALLOWED_ATTRS.includes(attr.name.toLowerCase())) {
          el.removeAttribute(attr.name);
        }
        // Remove event handlers
        if (attr.name.startsWith('on')) {
          el.removeAttribute(attr.name);
        }
        // Validate href
        if (attr.name === 'href') {
          try {
            const url = new URL(attr.value, location.origin);
            if (!ALLOWED_PROTOCOLS.includes(url.protocol)) {
              el.removeAttribute('href');
            }
          } catch {
            el.removeAttribute('href');
          }
        }
      });
    }
    Array.from(node.childNodes).forEach(clean);
  }

  clean(doc.body);
  return doc.body.innerHTML;
}
```

### Strategy 2: Text Content Instead of HTML

For cases where HTML is not required:

```typescript
// Instead of
<div [innerHTML]="userInput"></div>

// Use
<div>{{ userInput }}</div>
```

### Strategy 3: URL Validation

For URL-based XSS:

```typescript
function validateUrl(url: string): string {
  const BLOCKED_PROTOCOLS = ['javascript:', 'data:', 'vbscript:'];

  try {
    const parsed = new URL(url, location.origin);
    if (BLOCKED_PROTOCOLS.some(p => parsed.protocol === p)) {
      return '';
    }
    return url;
  } catch {
    return '';
  }
}
```

### Strategy 4: Safe Pipe for Static Content

For trusted, static content only:

```typescript
@Pipe({ name: 'safeHtml', standalone: true })
export class SafeHtmlPipe implements PipeTransform {
  constructor(private sanitizer: DomSanitizer) {}

  transform(html: string): SafeHtml {
    // WARNING: Only use for TRUSTED content
    return this.sanitizer.bypassSecurityTrustHtml(html);
  }
}
```

## Output Format

```markdown
## Secure Fix for [Vulnerability Type]

### Original Vulnerable Code
`file.ts:line`
```typescript
// Vulnerable code
```

### Secure Implementation
```typescript
// Fixed code with comments explaining security
```

### Security Explanation
[Why this fix prevents the attack]

### Test Cases
```typescript
// Test payloads that should be blocked
const attacks = [
  '<script>alert(1)</script>',
  '<img src=x onerror=alert(1)>',
  'javascript:alert(1)'
];
```
```

## Usage

```
/fix-xss-vulnerability [description of the vulnerability]
```

Examples:
```
/fix-xss-vulnerability innerHTML binding with user comments in xss-innerhtml.component.ts
/fix-xss-vulnerability bypassSecurityTrustHtml in user profile component
/fix-xss-vulnerability URL parameter reflected without encoding
```
